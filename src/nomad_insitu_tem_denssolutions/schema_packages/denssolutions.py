#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from datetime import datetime
from typing import TYPE_CHECKING

import numpy as np
import pandas as pd
import plotly.express as px
from nomad.config import config
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.basesections import Measurement, MeasurementResult
from nomad.datamodel.metainfo.plot import PlotlyFigure, PlotSection
from nomad.metainfo import Quantity, SchemaPackage, Section, SubSection

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger

# m_package = Package(name='DensSolutions')
configuration = config.get_plugin_entry_point(
    'nomad_insitu_tem_denssolutions.schema_packages:denssolutions'
)

m_package = SchemaPackage()


class Results(MeasurementResult):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    time_stamp = Quantity(
        type=str,
        description='Time stamp series of the measurement',
        # a_eln={'component': 'StringEditQuantity'},
        shape=['*'],
    )
    experiment_time = Quantity(
        type=np.float64,
        description='Time series of the measurement',
        # a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 's'},
        unit='s',
        shape=['*'],
    )
    temperature_setpoint = Quantity(
        type=np.float64,
        description='Setpoint temperature series of the measurement',
        # a_eln={
        #     'component': 'NumberEditQuantity',
        #     'defaultDisplayUnit': 'degree_Celsius',
        # },
        unit='degree_Celsius',
        shape=['*'],
    )
    temperature_measured = Quantity(
        type=np.float64,
        description='Measured temperature series of the measurement',
        # a_eln={
        #     'component': 'NumberEditQuantity',
        #     'defaultDisplayUnit': 'degree_Celsius',
        # },
        unit='degree_Celsius',
        shape=['*'],
    )
    measured_power = Quantity(
        type=np.float64,
        description='Measured power series of the measurement',
        # a_eln={'component': 'NumberEditQuantity', 'defaultDisplayUnit': 'W'},
        unit='W',
        shape=['*'],
    )
    relative_power_reference = Quantity(
        type=np.float64,
        description='Relative power reference series of the measurement',
        # a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
    )
    relative_power = Quantity(
        type=np.float64,
        description='Relative power series of the measurement',
        # a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
    )


class DensSolutionsInsituMeasurement(
    Measurement, PlotSection, EntryData, ArchiveSection
):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    csv_data_file = Quantity(
        type=str,
        description='Upload the csv data file here.',
        a_eln={'component': 'FileEditQuantity'},
        a_browser={'adaptor': 'RawFileAdaptor'},
    )
    log_data_file = Quantity(
        type=str,
        description='Upload the log data file here',
        a_eln={'component': 'FileEditQuantity'},
        a_browser={'adaptor': 'RawFileAdaptor'},
    )
    experiment_duration = Quantity(
        type=np.float64,
        description='Duration of the experiment',
        unit='s',
    )
    sample_description = Quantity(
        type=str,
        description='Description of the sample',
        a_eln={'component': 'StringEditQuantity'},
    )
    calibration_value = Quantity(
        type=np.float64,
        description='Calibration value',
    )
    room_temperature = Quantity(
        type=np.float64,
        description='Room temperature',
        unit='degree_Celsius',
    )
    max_temperature = Quantity(
        type=np.float64,
        description='Maximum temperature',
        unit='degree_Celsius',
    )
    medium = Quantity(
        type=str,
        description='Medium',
        a_eln={'component': 'StringEditQuantity'},
    )
    description = Quantity(
        type=str,
        description='Description of the experiment',
        a_eln={
            'component': 'StringEditQuantity',
        },
    )
    live_notes = Quantity(
        type=str,
        description='Live notes',
        a_eln={
            'component': 'RichTextEditQuantity',
        },
    )

    results = SubSection(
        section_def=Results,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `DensSolutions` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        # super().normalize(archive, logger)

        def custom_date_parser(x):
            return datetime.strptime(x, '%H:%M:%S.%f')

        def convert_timestamp_to_seconds(timestamp):
            # Replace the first dot with a colon to maintain the format consistency
            timestamp = timestamp.replace('.', ':', 1)
            # Split the timestamp into components
            hours, minutes, seconds, milliseconds = map(float, timestamp.split(':'))
            # Convert the components into seconds
            total_seconds = (
                (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000)
            )
            return total_seconds

        if self.csv_data_file:
            with archive.m_context.raw_file(self.csv_data_file) as file:
                impulse_data = pd.read_csv(
                    file,
                    sep=',',
                    header=0,
                )
                results = Results()
                results.time_stamp = impulse_data['TimeStamp'].values
                results.experiment_time = impulse_data['Experiment time'].values
                results.temperature_setpoint = impulse_data[
                    'Temperature Setpoint'
                ].values
                results.temperature_measured = impulse_data[
                    'Temperature Measured'
                ].values
                results.measured_power = impulse_data['Measured power'].values
                results.relative_power_reference = impulse_data[
                    'Relative power reference'
                ].values
                results.relative_power = impulse_data['Relative power'].values
                self.results = [results]

            if self.results[0]:
                fig = px.line(
                    x=self.results[0].experiment_time,
                    y=self.results[0].temperature_measured,
                    title='Measured Temperature',
                    labels={'x': 'Time (s)', 'y': 'Measured T (Â°C)'},
                )
                fig.update_layout(
                    xaxis=dict(
                        fixedrange=False,
                    ),
                    yaxis=dict(
                        fixedrange=False,
                    ),
                )
                self.figures = []
                self.figures.append(
                    PlotlyFigure(
                        label='Temperature vs Time',
                        index=1,
                        figure=fig.to_plotly_json(),
                    )
                )
        if self.log_data_file:
            with archive.m_context.raw_file(self.log_data_file, 'r') as file:
                log_data = file.readlines()
                for line in log_data:
                    if line.startswith('Experiment date'):
                        date = line.split(', ')[1].strip()
                    elif line.startswith('Experiment time'):
                        time = line.split(', ')[1].strip()
                        self.datetime = datetime.strptime(
                            (date + ' ' + time), '%d-%m-%Y %H:%M:%S'
                        )

                    elif line.startswith('Duration'):
                        experiment_duration = line.split(', ')[1].strip()
                        self.experiment_duration = convert_timestamp_to_seconds(
                            experiment_duration
                        )
                    elif line.startswith('Sample'):
                        self.sample_description = line.split(', ')[1].strip('"\n')
                    elif line.startswith('Description'):
                        self.description = line.split(', ')[1].strip('"\n')
                    elif line.startswith('Calibration value'):
                        self.calibration_value = float(line.split(', ')[1].strip())
                    elif line.startswith('Room temperature'):
                        self.room_temperature = float(line.split(', ')[1].strip())
                    elif line.startswith('Max temperature'):
                        self.max_temperature = float(line.split(', ')[1].strip())
                    elif line.startswith('Medium'):
                        self.medium = line.split(', ')[1].strip()
                    elif line.startswith('Live notes'):
                        self.live_notes = line.split('s, ')[1].strip()

                # super().normalize(archive, logger)

        super().normalize(archive, logger)


m_package.__init_metainfo__()
